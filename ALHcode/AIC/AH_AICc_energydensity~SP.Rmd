---
title: "AH_AICc_energydensity~SP"
author: "Abby Host"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, eval = TRUE)
```

### Loading Data
```{r}
rm(list = ls())
library(AICcmodavg)
library(lubridate)
library(ggplot2)

#data loading
# bc19 <- read.csv("bodycomp_2019.csv")
# bc20 <- read.csv("bodycomp_2020.csv")
# bc21 <- read.csv("bodycomp_2021.csv")
#need to bind all together for total body comp dataset, Upper River river only

# bc_UR_total <- rbind(bc19[61:172,], bc20[61:120,], bc21[61:182,])
# write.csv(bc_UR_total, "upperriver_bodycomp_all.csv")
upperriver_bodycomp_all<-read.csv("upperriver_bodycomp_all.csv")[,-1]
#all data is loaded now

#need to add year to dataset
str(upperriver_bodycomp_all)
upperriver_bodycomp_all$Collection_Date <- as.Date(upperriver_bodycomp_all$Collection_Date)

# Create a new column 'year' from the collection_date
upperriver_bodycomp_all$Year <- year(upperriver_bodycomp_all$Collection_Date)
str(upperriver_bodycomp_all)

#replace blank cell in Sex with NA 
upperriver_bodycomp_all$Sex[upperriver_bodycomp_all$Sex == ""] <- NA
str(upperriver_bodycomp_all)

write.csv(upperriver_bodycomp_all, "upperriver_bodycomp_all.csv")
```

### Import Data for models, check for NAs and eliminate as needed

```{r, include = FALSE}
rm(list = ls())
upperriver_bodycomp_all <- "upperriver_bodycomp_all.csv"
DataSet<-read.csv(upperriver_bodycomp_all)[,-1]

##### For the Upper River Data, I want to elimiate Power Creek Cordova, Eyak Weir Cordova, Bone Creek, Klutina River, and Upper Klutina, and Copper Lake data points as they don't apply to my spawning populations of interest ####
library(dplyr)

# Use filter() to exclude the specific collection locations
DataSet <- DataSet %>%
  filter(!Collection_Location %in% c("Power Creek Cordova", "Eyak Weir Cordova", "Bone Creek", "Copper Lake", "Klutina River", "Upper Klutina"))

#convert gonad_wt to grams from kilograms
DataSet$Gonad_Wt_g <- DataSet$Gonad_Wt * 1000

### Now, need to remove NAs that will mess up levels / model weight
any(is.na(DataSet$Collection_Location))
any(is.na(DataSet$Year))
any(is.na(DataSet$Sex))
DataSet[is.na(DataSet$Sex), ] #row 87 and 110 has no sex value, eliminate it for models
DataSet[is.na(DataSet$EnergyPDry_1), ] #Row 35 does not have a Energy Content 1 value, so eliminate for analysis
#check gonad weight for NAs
any(is.na(DataSet$Gonad_Wt_g))
DataSet[is.na(DataSet$Gonad_Wt_g), ] #need to eliminate these rows or model selection will not work
DataSet <- DataSet[-c(18,35,36,40,61,65,77,87,102,110,118,141,142,144,161, 164,221, 222,224),] #excludes row missing sex file
any(is.na(DataSet$Sex)) #FALSE
any(is.na(DataSet$Gonad_Wt_g)) #FALSE
any(is.na(DataSet$EnergyPDry_1)) #FALSE


# View DataSet.
head(DataSet)
summary(DataSet)
nrow(DataSet)
str(DataSet) #220 observations and 82 variables

#Make work metric (migratory difficulty metric where work = F x distance)
DataSet$Elevation_m <- as.numeric(DataSet$Elevation_m)
DataSet$Work <- round((DataSet$Collection_RiverMile_m * DataSet$Elevation_m) / (1000 * 1000), digits = 1) #in km^2
str(DataSet) 



#make response variables factors
DataSet$Collection_Location <- as.factor(DataSet$Collection_Location)
levels(DataSet$Collection_Location) # 7 unique locations
DataSet$Year<- as.factor(DataSet$Year)
levels(DataSet$Year)
DataSet$Sex<- as.factor(DataSet$Sex)
str(DataSet)


```


### Making Models for EnergyPDry_1~SpawningPopulation, includes SpawnStatus
```{r}
# Models for reference
energypdry_SP_modelset <- "energydensity_spawningpopulation/EnergyPDry_1~SpawningPopulation_modelset.csv"

ModelSet<-read.csv(energypdry_SP_modelset)
# DataSet$Work <- factor(DataSet$Work) #This is an important fix, otherwise its numeric but in fact its discrete factors


model1 <- lm(EnergyPDry_1~1, data=DataSet)
model2 <- lm(EnergyPDry_1~ Gonad_Wt_g + Collection_Location, data = DataSet)
model3 <- lm(EnergyPDry_1~ Gonad_Wt_g + Sex, data = DataSet)
model4 <- lm(EnergyPDry_1~Gonad_Wt_g + Year, data = DataSet)
model5 <- lm(EnergyPDry_1~ Gonad_Wt_g + Collection_Location + Sex, data = DataSet)
model6 <- lm(EnergyPDry_1~ Gonad_Wt_g + Collection_Location + Year, data = DataSet)
model7 <- lm(EnergyPDry_1~ Gonad_Wt_g + Sex + Year, data = DataSet)
model8 <- lm(EnergyPDry_1~ Gonad_Wt_g + Collection_Location + Sex + Collection_Location:Sex, data = DataSet)
model9 <- lm(EnergyPDry_1~Gonad_Wt_g + Sex + Year + Sex:Year, data = DataSet)
model10 <- lm(EnergyPDry_1~ Gonad_Wt_g + Collection_Location + Sex + Year, data = DataSet)

```

### AICc Model Selection
```{r}
AIC(model1, model2, model3, model4, model5, model6, model7, model8, model9, model10)

edModels <- list(model1, model2, model3, model4, model5, model6, model7, model8, model9, model10)

# Generate AIC table
mynames_ed <- paste("model", as.character(1:10), sep = "")
ed_aicc <- aictab(edModels, modnames = mynames_ed)
print(ed_aicc) 

# Convert AIC table to a data frame for easier manipulation
EDaic_df <- as.data.frame(ed_aicc)
EDaic_df$ModelName <- c("EnergyPDry_1~ Gonad_Wt_g + Collection_Location + Sex + Year",
                        "EnergyPDry_1~ Gonad_Wt_g + Collection_Location + Year",
                        "EnergyPDry_1~ Gonad_Wt_g + Collection_Location + Sex",
                        "EnergyPDry_1~ Gonad_Wt_g + Collection_Location",
                        "EnergyPDry_1~ Gonad_Wt_g + Collection_Location + Sex + Collection_Location:Sex",
                        "EnergyPDry_1~ Gonad_Wt_g + Sex + Year",
                        "EnergyPDry_1~Gonad_Wt_g + Sex + Year + Sex:Year",
                        "EnergyPDry_1~Gonad_Wt_g + Year",
                        "EnergyPDry_1~ Gonad_Wt_g + Sex",
                        "EnergyPDry_1~1")
colnames(EDaic_df)[colnames(EDaic_df) == "Modnames"] <- "Model #"

write.csv(EDaic_df, file = "energydensity_spawningpopulation/AICresults_EnergyPDry_1~SpawningPopulation.csv", row.names = FALSE)

```

### Model Averaging and Parameter Likelihoods
```{r}
# ---- Load necessary packages ----
library(MuMIn)

# List your models (already fit with na.action=na.fail)
models <- list(model1, model2, model3, model4, model5, model6, model7, model8, model9, model10)

# Model averaging based on AICc, conditional averaging (default is full=TRUE)
model_avg <- model.avg(models, rank = "AICc", full = TRUE)

# Summary with coefficients, SE, CIs
summary(model_avg)

# Full averaged coefficients
avg_coefs_full <- coef(model_avg, full = TRUE)

# Full averaged confidence intervals
avg_confint_full <- confint(model_avg, full = TRUE)

# Full averaged variance-covariance matrix and SE
avg_vcov_full <- vcov(model_avg, full = TRUE)
avg_se_full <- sqrt(diag(avg_vcov_full))

# Create tidy data frame with full averages
coefs_df_full <- as.data.frame(avg_coefs_full)
colnames(coefs_df_full) <- "Avg_Coef"
coefs_df_full$CI_Lower <- avg_confint_full[, 1]
coefs_df_full$CI_Upper <- avg_confint_full[, 2]
coefs_df_full$SE <- avg_se_full

# Calculate parameter importance (parameter likelihoods)
param_likelihoods <- sw(model_avg)
as.data.frame(param_likelihoods)

# Manually specify parameter likelihoods from sw(model_avg)
manual_likelihoods <- c(
  "(Intercept)" = 1.0,
  "Gonad_Wt_g" = 1.000000,
  "Collection_LocationGulkana Hatchery" = 1.000000, 
  "Collection_LocationLong Lake" = 1.000000,
  "Collection_LocationMahlo" = 1.000000,
  "Collection_LocationMentasta" = 1.000000,
  "Collection_LocationSt Anne" = 1.000000,
  "Collection_LocationTanada" = 1.000000,
  "Year2020" = 0.9999670,
  "Year2021" = 0.9999670, 
  "SexM" = 0.9939664,
  "SexM:Year2020" = 2.640805e-21,
  "SexM:Year2021" = 2.640805e-21,
  "Collection_LocationGulkana Hatchery:SexM" = 2.917088e-07,
  "Collection_LocationLong Lake:SexM" = 2.917088e-07,
  "Collection_LocationMahlo:SexM" = 2.917088e-07,
  "Collection_LocationMentasta:SexM" = 2.917088e-07,
  "Collection_LocationSt Anne:SexM" = 2.917088e-07,
  "Collection_LocationTanada:SexM" = 2.917088e-07
)




# Add ParamLikelihoods by matching rownames
coefs_df_full$ParamLikelihood <- manual_likelihoods[rownames(coefs_df_full)]

# View final table
print(coefs_df_full)

write.csv(coefs_df_full, "energydensity_spawningpopulation/Energydensity_SpawningPopulation_ModelAvg_Coefs_withLikelihoods.csv", row.names = TRUE)

```

### Using summed weighted parameter estimates for energy density by CL ~ work (successful size for migration, as continuous variable)
```{r}
# Step 1: Extract intercept
intercept <- coefs_df_full["(Intercept)", "Avg_Coef"]

# Step 2: Extract Collection_Location effects
location_effects <- coefs_df_full[grep("^Collection_Location", rownames(coefs_df_full)), ]
location_effects <- location_effects[!grepl(":", rownames(location_effects)), ]  # remove interaction terms

# Extract location names (remove "Collection_Location" from row names)
location_effects$Location <- gsub("Collection_Location", "", rownames(location_effects))

# Step 3: Add intercept to each to get estimated body size
location_effects$Estimated_EnergyPDry <- intercept + location_effects$Avg_Coef

# Step 4: Add back the reference location (intercept only)
ref_location <- levels(DataSet$Collection_Location)[1]  # Assumes first level is the reference
ref_row <- data.frame(
  Avg_Coef = intercept,
  CI_Lower = coefs_df_full["(Intercept)", "CI_Lower"],
  CI_Upper = coefs_df_full["(Intercept)", "CI_Upper"],
  SE = coefs_df_full["(Intercept)", "SE"],
  ParamLikelihood = coefs_df_full["(Intercept)", "ParamLikelihood"],
  Location = ref_location,
  Estimated_EnergyPDry = intercept
)

# Step 5: Combine
location_estimates <- rbind(ref_row, location_effects)
rownames(location_estimates) <- NULL
location_estimates <- location_estimates[, c("Location", setdiff(names(location_estimates), "Location"))]

# Step 6: Compute average Work per location
library(dplyr)
avg_work <- DataSet %>%
  group_by(Collection_Location) %>%
  summarise(Avg_Work = mean(Work, na.rm = TRUE))

# Step 7: Merge with estimates
location_estimates <- merge(location_estimates, avg_work, by.x = "Location", by.y = "Collection_Location")

# Step 8: Linear regression of estimated body size ~ work
ed_work_model <- lm(Estimated_EnergyPDry ~ Avg_Work, data = location_estimates)
summary(ed_work_model)

# Step 9: Visualization
library(ggplot2)
ggplot(location_estimates, aes(x = Avg_Work, y = Estimated_EnergyPDry, label = Location)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  geom_text(nudge_y = 0.1, size = 3) +
  labs(title = "Model-Averaged Estimated Energy Content (mJ/kg) vs. Migration Work",
       x = "Migration Work (km²)", y = "Estimated Energy Content (mJ/kg)") +
  theme_minimal() + 
   theme(
  plot.title = element_text(size = 16, face = "bold"),
  axis.title.x = element_text(size = 16, face = "bold"),
  axis.title.y = element_text(size = 16, face = "bold"),
  axis.text.x = element_text(size = 16),
  axis.text.y = element_text(size = 16),
  legend.title = element_text(size = 16, face = "bold"),
  legend.text = element_text(size = 16)
)


#Remove Long Lake from the dataset
location_estimates_noLL <- location_estimates %>%
  filter(!Location %in% c("Long Lake"))

ed_work_model2 <- lm(Estimated_EnergyPDry ~ Avg_Work, data = location_estimates_noLL)
summary(ed_work_model2)

ggplot(location_estimates_noLL, aes(x = Avg_Work, y = Estimated_EnergyPDry, label = Location)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  geom_text(nudge_y = 0.1, size = 3) +
  labs(title = "Model-Averaged Estimated Energy Content vs. Migration Work",
       x = "Migration Work (km²)", y = "Estimated Energy Content (mJ/kg)") +
  theme_minimal() +
  theme(
  plot.title = element_text(size = 16, face = "bold"),
  axis.title.x = element_text(size = 16, face = "bold"),
  axis.title.y = element_text(size = 16, face = "bold"),
  axis.text.x = element_text(size = 16),
  axis.text.y = element_text(size = 16),
  legend.title = element_text(size = 16, face = "bold"),
  legend.text = element_text(size = 16)
)
  

```



### Figure that displays parameter estimates + CI for each parameter in the model set
```{r}
paramestimates_energypdry <- "energydensity_spawningpopulation/energydensity_spawningpopulation_ModelAvg_Coefs_withLikelihoods.csv"

paramestimates_energy<-read.csv(paramestimates_energypdry)
str(paramestimates_energy)

levels(factor(paramestimates_energy$Parameter))
paramestimates_energy$Parameter <- factor(paramestimates_energy$Parameter, 
                           levels = rev(factor(paramestimates_energy$Parameter)))


library(ggplot2)
ggplot(paramestimates_energy, aes(x = Avg_Coef, y = Parameter)) + 
  geom_point(size = 3) +  # For the coefficient estimate as dots
  geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0.2) + # Horizontal CI bars
  labs(x = "Parameter Estimate", y = "Parameter") +
  geom_vline(xintercept = 0, color = "red", linetype = "dashed", size = 1) +
  theme_minimal() 
  # + theme(axis.title = element_text(size = 24), 
       # axis.text = element_text(size = 24))

```








### Figures for Copper River Workshop February 2025
```{r, echo=TRUE, results='hide', warning=FALSE, message=FALSE}
# Pete wants a figure/visualization of energy content of various spawning populations

rm(list = ls())
upperriver_bodycomp_all <- "upperriver_bodycomp_all.csv"
DataSet<-read.csv(upperriver_bodycomp_all)[,-1]

##### For the Upper River Data, I want to elimiate Power Creek Cordova, Eyak Weir Cordova, Bone Creek, and Copper Lake data points as they don't apply to my spawning populations of interest ####
library(dplyr)

# Assuming your data frame is named df, use filter() to exclude the specific collection locations
DataSet <- DataSet %>%
  filter(!Collection_Location %in% c("Power Creek Cordova", "Eyak Weir Cordova", "Bone Creek", "Copper Lake", "Klutina River", "Upper Klutina"))


### Now, need to remove NAs that will mess up levels / model weight
any(is.na(DataSet$Collection_Location))
any(is.na(DataSet$Migratory_Difficulty))
any(is.na(DataSet$Year))
any(is.na(DataSet$Sex))
DataSet[is.na(DataSet$Sex), ] #row 87 and 110 has no sex value, eliminate it for models
DataSet <- DataSet[-c(87,110),] #excludes row missing sex file
any(is.na(DataSet$Sex))

#Response variable, check for NAs
any(is.na(DataSet$EnergyPDry_1))
DataSet[is.na(DataSet$EnergyPDry_1), ] #Row 35 does not have a Energy Content 1 value, so eliminate for analysis
DataSet <- DataSet[-c(35),]
any(is.na(DataSet$EnergyPDry_1)) # False

#make response variables factors
DataSet$Collection_Location <- as.factor(DataSet$Collection_Location)
levels(DataSet$Collection_Location) # 7 unique locations
DataSet$Year<- as.factor(DataSet$Year)
DataSet$Sex<- as.factor(DataSet$Sex)
DataSet$Migratory_Difficulty <- as.factor(DataSet$Migratory_Difficulty)
levels(DataSet$Migratory_Difficulty) # 4 Levels
DataSet$Migratory_Difficulty <- factor(DataSet$Migratory_Difficulty,
                                       levels = c("Low",
                                                  "Middle",
                                                  "Middle-High",
                                                  "High")) #re-leveling
DataSet$SpawnStatus <- as.factor(DataSet$SpawnStatus) #should be 4 levels
str(DataSet)



DataSet2 <- DataSet %>%
  filter(Strontium_marked_Y.N != "NO READ")
DataSet2$Strontium_marked_Y.N <- as.factor(DataSet2$Strontium_marked_Y.N)
levels(DataSet2$Strontium_marked_Y.N) #Now only Y and N available


                #### Strontium Analysis of Energy ######
str(DataSet2)
#first I want to determine which collection_location levels contain fish samples with both Y and N strontium markings for comparison of energyPdry_1
locations_with_both <- DataSet2 %>%
  group_by(Collection_Location) %>%
  filter(any(Strontium_marked_Y.N == "Y") & any(Strontium_marked_Y.N == "N")) %>%
  pull(Collection_Location) %>%
  unique()

# Filter dataset to keep only the locations with both "Y" and "N" levels
strontium_data <- DataSet2 %>%
  filter(Collection_Location %in% locations_with_both)

#So all of this Y fish are in Gulkana or Fish creek with an exception of one return fish that was collected at Mentasta-- important to note! but for the sake of visualization, I am removing that fish
strontium_data <- strontium_data %>%
  filter(Collection_Location != "Mentasta")


library(ggplot2)
#Now, I want to further visualize this by year (2019, 2020, 2021)
# Boxplot comparing EnergyPDry_1 by Strontium Y/N and Year
ggplot(strontium_data, aes(x = Strontium_marked_Y.N, y = EnergyPDry_1, fill = Strontium_marked_Y.N)) +
  geom_boxplot() +
  facet_grid(~ Year) + 
  labs(title = "The energy content (mJ/kg) of strontium marked and non-marked sockeye from Gulkana Hatchery and Fish Creek \nduring the 2019-2021 sampling seasons.",
       x = "Strontium Level (Y/N)",
       y = "Energy (EnergyPDry_1)",
       fill = "Presence of \nStrontium Mark") + 
  theme_classic() +
  scale_x_discrete(labels = c("Y" = "Marked", "N" = "Non-Marked")) + 
  scale_fill_manual(values = c("Y" = "red", "N" = "blue"),
                    labels = c("Y" = "Marked", "N" = "Non-Marked"))  # Change legend labels




                ##### Energy Analysis of Pre-Spawn Fish #####

# use filter() to exclude the any partial/post/anomolous spawned fish
DataSet_prespawn <- DataSet %>%
  filter(!SpawnStatus %in% c("1","2","3"))

# use filter() to exclude the any partial/anomolous spawned fish
DataSet_prepostspawn <- DataSet %>%
  filter(!SpawnStatus %in% c("1","3"))



# Relevel the factor in one step
DataSet_prespawn$Collection_Location <- factor(DataSet_prespawn$Collection_Location,
                             levels = c("Long Lake", 
                                      "Mahlo", 
                                      "St Anne",
                                      "Mentasta", 
                                      "Tanada", 
                                      "Gulkana Hatchery", 
                                      "Fish Creek Gulkana"))

  # Faceted boxplot by Year and Collection Location
ggplot(DataSet_prespawn, aes(x = Collection_Location, y = EnergyPDry_1)) +
  geom_boxplot(aes(fill = Collection_Location), alpha = 0.6) +
  facet_wrap(~ Year) +
  labs(title = "Differences of energy content (mJ/kg) of pre-spawn sockeye sampled from different \nspawning locations in the Copper River Basin, separated by sampling year (2019-2021)",
       x = "Collection Location",
       y = "Energy Content (mJ/kg)") + 
   guides(fill = "none") + 
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1))




### Pre vs Post Spawn energy differences in sockeye for 2019-2021 only
# Ensure 'Year' is a factor variable (if not already)
DataSet_prepostspawn$Year <- as.factor(DataSet_prepostspawn$Year)

#Per Pete's request, filter data so that it includes collection_locations only that contain pre AND post data points:
library(dplyr)

location_summary <- DataSet %>%
  filter(SpawnStatus %in% c(0, 2)) %>%  # Keep only 0 and 2
  group_by(Collection_Location) %>%
  summarise(has_pre_spawn = any(SpawnStatus == 0), 
            has_post_spawn = any(SpawnStatus == 2)) %>%
  filter(has_pre_spawn & has_post_spawn)  # Keep only locations with both 0 and 2

# View the table
print(location_summary)

DataSet_prepostspawnLoc <- DataSet %>%
  filter(!SpawnStatus %in% c("1", "3")) %>%  # Exclude SpawnStatus 1 and 3
  group_by(Collection_Location) %>%
  filter(all(c(0, 2) %in% SpawnStatus)) %>%
  ungroup()  # Remove grouping after filtering


ggplot(DataSet_prepostspawnLoc, aes(x = SpawnStatus, y = EnergyPDry_1, fill = SpawnStatus)) +
  geom_boxplot(alpha = 0.6) + # Color for pre-spawn and post-spawn
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Differences of energy content (mJ/kg) between pre-spawn and \npost-spawn sockeye sampled in the Copper River Basin from 2019-2021",
       x = "Spawn Status",
       y = "Energy Content (mJ/kg)",
       fill = "SpawnStatus") +
  facet_wrap(~ Collection_Location) +
  theme_classic() +   
  scale_fill_manual(values = c("0" = "skyblue", "2" = "salmon"),
                    labels = c("0" = "Pre-Spawn", "2" = "Post-Spawn")) + 
  scale_x_discrete(labels = c("0" = "Pre-Spawn", "2" = "Post-Spawn"))



### Include partial spawn data for long lake
str(DataSet)
library(dplyr)

DataSet_prepartialspawnLoc <- DataSet %>%
  filter(!SpawnStatus %in% c("2", "3")) %>%  # Exclude SpawnStatus 2 and 3
  group_by(Collection_Location) %>%
  filter(all(c(0, 1) %in% SpawnStatus)) %>%
  ungroup()  # Remove grouping after filtering


gpartial <- ggplot(DataSet_prepartialspawnLoc, aes(x = SpawnStatus, y = EnergyPDry_1, fill = SpawnStatus)) +
  geom_boxplot(alpha = 0.6) + # Color for pre-spawn and post-spawn
  labs(title = "Differences of energy content (mJ/kg) between pre-spawn and \npartial-spawn sockeye sampled in the Copper River Basin from 2019-2021",
       x = "Spawn Status",
       y = "Energy Content (mJ/kg)",
       fill = "SpawnStatus") +
  facet_wrap(~ Collection_Location) +
  theme_classic() +   
  scale_fill_manual(values = c("0" = "skyblue", "1" = "purple"),
                    labels = c("0" = "Pre-Spawn", "1" = "Partial-Spawn")) + 
  scale_x_discrete(labels = c("0" = "Pre-Spawn", "1" = "Partial-Spawn"))



ggplot(DataSet_prepartialspawnLoc, aes(x = SpawnStatus, y = EnergyPDry_1, fill = SpawnStatus)) +
  geom_boxplot(alpha = 0.6) + # Color for pre-spawn and post-spawn
  labs(title = "Differences of energy content (mJ/kg) between pre-spawn and \npartial-spawn sockeye sampled in the Copper River Basin from 2019-2021",
       x = "Spawn Status",
       y = "Energy Content (mJ/kg)",
       fill = "SpawnStatus") +
  facet_wrap(~ Collection_Location) +
  theme_classic() +   
  scale_fill_manual(values = c("0" = "skyblue", "1" = "purple"),
                    labels = c("0" = "Pre-Spawn", "1" = "Partial-Spawn")) + 
  scale_x_discrete(labels = c("0" = "Pre-Spawn", "1" = "Partial-Spawn"))

```
